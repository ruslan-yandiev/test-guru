# именуем модуль Auth и помещаем его в пространство имен User 
# по факту у нас будет модуль Auth внутри класса User, дальше подключим этот модуль внутри
# класса модели User
module User::Auth
  
  # подключим к синглтону модуля Concern и это позволит использовать блок included do
  extend ActiveSupport::Concern

  # такую технику в рельсах называют виртуальными атрибутами, а виртуальные потому, что данные находятся у объекта
  # и не сохраняются в базе. Короче обычные геттеры, сеттеры и ассесоры
  attr_reader :password
  attr_writer :password_confirmation #ридер определим с помощью валидации

  # все, что внутри блока находится будет вызвано в момент подключения модуля на уровне класса
  # необходимо, чтобы подключить и использовать методы класса validates при подключенииих из модуля
  included do
	  # проверим на существование эмайл и его минимальный размер
	  validates :email, presence: true, length: { minimum: 5 }
	  
	  # несмотря на то, что password является атрибутом на уровне модели(виртуальный атрибут), но не хранится в базе тем неменее блягодаря
	  # ActiveModel мы точно также можем к данным полям(переменным) применять стандартные валидации
	  # Чтобы можно было бы не только создать пароль но и обновлять его добавим условие в параметры объект класса Proc
	  # У текущего объекта(пользователя) проверим существует ли какое то значение в атрибуте(колонке) password_digest и если там nil или пустая строка
	  # то дагда мы должны выполнить данную валидацию и требовать наличие атрибута пассворд
	  validates :password, presence: true, length: { minimum: 5 }, if: Proc.new { |u| u.password_digest.blank? }

	  # эта валидация добавляет ридер для поля пассворд и будет проверять, что если внутри атрибута password_confirmation(вирт атриб) находится какое то значение
	  # то оно должно соответствовать тому значению которое находится в атрибуте password
	  validates :password, confirmation: true
  end

  def authenticate(password_string)
    # будем вычислять некоторый хэш от password_string с помощью метода digest
    # и сравнивать его с тем значением атрибута password_digest который хранится в базе
    digest(password_string) == self.password_digest ? self : false
  end

  def password=(password_string)
    if password_string.nil?
      self.password_digest = nil
    elsif password_string.present? # present? метод ActiveSupport проверит содержит ли аргумент password_string отличное значение от nil и пустой строки
      @password = password_string
      # self нужно обязательно указать, что бы руби не принял password_digest за локальную переменную
      self.password_digest = digest(password_string)
    end
  end

  private

  def digest(string)
    # воспользуемся алгоритмом для вычисления хэша из стандартной библиотеки ruby SHA1
    # и сделаем это с помощью метода hexdigest
    # При хэшировании мы используем в нашем случае только пароль пользователя, но для большей безопасности мы можем
    # добавлять к паролю определенную соль(случайное сгенерированное значение, которая также хранится отдельно в таблице users и
    # связана с определенным пользователем):  Digest::SHA1.hexdigest(string + salt)
    Digest::SHA1.hexdigest(string)
  end
end